---
title: "R Programming - Week 2"
author: "Mike Talley"
date: "2/20/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Control Structures

## If-else

We can tell R to do something IF certain conditions are met. The ELSE is optional, but will specify what to do if the conditions are not met. 
```{r}
x <- 5

if(x > 3) {y <- 10} else {y <- 0}

#or

y <- if(x > 3) {10} else {0}
```

## For loops

For loops are typically the most common type of loops used. They are most commonly used for iterating over the elements of an object (list, vector, etc). The basic idea is that you have a loop index which is typically called i, but if you have many loops you might say j, k, l, et cetera. And a loop index is going to take the i variable and each time it loops it will give it a value, and then will exit when finished.

```{r}
for(i in 1:10) {print(i)}

x <- c("a", "b", "c", "d")

for(i in 1:4) {print(x[i])}

for(i in seq_along(x)) {print(x[i])}

for(letter in x) {print(letter)}

for(i in 1:4) print(x[i])
```
You can also have nested loops, or a loop within another loop. Be careful with this though, as going more than 2-3 levels deep is hard to understand/read. Like the movie inception!

```{r}
x <- matrix(1:6, 2, 3)

for(i in seq_len(nrow(x))) {
  for(j in seq_len(ncol(x))) {
    print(x[i, j])
  }
}
```
## While Loops

This is the other basic looping function in R. This tests a condition, and if true, executes the loop body. Once it is executed, it will test the condition again, and so forth. They can result in an inifite loop if done incorrectly, so be careful!

```{r}
## This loop will count up to 10, and when it reaches 10, the condition is then FALSE, so the loop will stop.

count <- 0
while(count < 10) {
  print(count)
  count <- count + 1
}
```
You can also use more than one condition in the test, which is handy. These conditions are ALWAYS EVALUATED FROM LEFT TO RIGHT. The following loop starts with z = 5. If z is between 3 and 10, it will print, and flip a coin. If heads, it adds 2 to z. If tails, it subtracts 2. This will continue until the original conditions are false.

```{r}
z <- 5

while(z >= 3 && z <= 10) {
  print(z)
  coin <- rbinom(1, 1, 0.5)
  
  if(coin == 1) { ## random walk
    z <- z + 2
  } else {z <- z - 2}
  }
```
## Repeat

These loops are endless, and are uncommon in statistics, but could have useful applications elsewhere. Algorithms can be dangerous if they never stop, so it is useful to define a set stopping point. 

## Next

This is used when you want to skip a portion or certain number of loops. Below is a next function where we skip the first two iterations.

```{r}
for(i in 1:10) {
  if(i <= 2) {   ## Skip the first 2 iterations until i > 2
    next
  }
  print(i)
}
```
## Functions

## Creating Our First Functions

```{r}
## Super simple function to add two numbers together.
add2 <- function(x, y) {
  x + y
}
add2(3, 5)


## A new function to return values greater than 10
above10 <- function(x) {
  use <- x > 10
  x[use]
}
above10(c(5, 10, 15, 20))


## A function to return values above another number that we choose.
above <- function(x, n) {
  use <- x > n
  x[use]
}
x <- 1:20
above(x, 14)

## We can make n be the same number unless otherwise specified.
above <- function(x, n = 10) {
  use <- x > n
  x[use]
}
x <- 1:20
above(x)
above(x, 14)

```
So far these are super simple functions on a single vector. The following will be a function applied to a matrix or dataframe. This one will calculate the mean of each column. We will use a for loop, and each time it loops it will return the mean of the next column.

We need to start by determining the number of columns in the vector, so it knows how many times to loop. We then create the vector 'means', and define it as a numeric = to the value of nc. With that all set up, we can create our for loop. We plug in 1:nc to tell it how many times to loop i. When it loops, it will be creating a vector means[i]. That vector is created by getting the mean of each column, mean(x[, i]).

The removeNA section is an option we can build in to automatically remove any NA values. This would have been a game changer on last weeks quiz. 

```{r}
columnmean <- function(x, removeNA = TRUE) {
  nc <- ncol(x)                       ## How many columns does it have
  means <- numeric(nc)                ## Defining means as a numeric vector
  for(i in 1:nc) {                    ## How many times are we looping? 1:nc
    means[i] <- mean(x[, i], na.rm = removeNA)  
  }                           ## When running, what are we looking for? 
  means                       ## Return means, so we list it at the end.
}

columnmean(airquality)
columnmean(airquality, FALSE)
```
Because our function automatically removes NA, we still have the option to include them, we just need to specify that in the command. 

